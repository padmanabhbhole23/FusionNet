# ============================================================
# âœ… Imports
# ============================================================
import os
import cv2
import numpy as np
import joblib
import tensorflow as tf
from tensorflow.keras.models import load_model
from flask import Flask, request, render_template_string
from werkzeug.utils import secure_filename

# ============================================================
# âœ… Parameters and Paths
# ============================================================
IMG_SIZE = (128, 128)
MAX_FRAMES = 40
MODEL_SAVE_DIR = "./models"  # Adjust this to your local models directory
UPLOAD_FOLDER = "./uploads"
ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov'}

# Create upload folder if it doesn't exist
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(MODEL_SAVE_DIR, exist_ok=True)  # Just in case

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# ============================================================
# âœ… Load Trained Models
# ============================================================
print("ðŸ“¦ Loading trained models...")
cnn_lstm_model = load_model(f"{MODEL_SAVE_DIR}/cnn_lstm_model.keras")
svm = joblib.load(f"{MODEL_SAVE_DIR}/svm_branch.pkl")
xgb = joblib.load(f"{MODEL_SAVE_DIR}/xgb_branch.pkl")
fusion = joblib.load(f"{MODEL_SAVE_DIR}/fusion_model.pkl")
pca = joblib.load(f"{MODEL_SAVE_DIR}/pca_transform.pkl")
print("âœ… Models loaded successfully!")

# ============================================================
# âœ… Helper Functions
# ============================================================
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def extract_frames_from_video(video_path, max_frames=MAX_FRAMES):
    cap = cv2.VideoCapture(video_path)
    frames = []
    frame_count = 0

    while True:
        ret, frame = cap.read()
        if not ret or frame_count >= max_frames:
            break
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        frame = cv2.resize(frame, IMG_SIZE)
        frames.append(frame)
        frame_count += 1

    cap.release()
    if len(frames) == 0:
        return None

    frames = np.array(frames, dtype="float32") / 255.0
    if len(frames) < max_frames:
        pad_len = max_frames - len(frames)
        pad = np.zeros((pad_len, IMG_SIZE[0], IMG_SIZE[1], 3), dtype="float32")
        frames = np.concatenate([frames, pad], axis=0)

    return frames

def predict_video(video_path):
    frames = extract_frames_from_video(video_path)
    if frames is None:
        return None, None, None, None

    # --- CNN+LSTM prediction ---
    frames_batch = np.expand_dims(frames, axis=0)
    lstm_prob = cnn_lstm_model.predict(frames_batch, verbose=0)[0][0]
    lstm_label = int(lstm_prob > 0.5)

    # --- Fusion Model prediction ---
    mean_frame = np.mean(frames, axis=0).flatten().astype(np.float64).reshape(1, -1)
    mean_frame_pca = pca.transform(mean_frame)
    fusion_prob = fusion.predict_proba(mean_frame_pca)[0][1]
    fusion_label = int(fusion_prob > 0.5)

    return lstm_label, lstm_prob, fusion_label, fusion_prob

# ============================================================
# âœ… Routes
# ============================================================
@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        if 'video' not in request.files:
            return render_template_string(ERROR_HTML, message="No file part")

        file = request.files['video']
        if file.filename == '':
            return render_template_string(ERROR_HTML, message="No selected file")

        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(video_path)

            # Run prediction
            lstm_label, lstm_prob, fusion_label, fusion_prob = predict_video(video_path)

            # Clean up uploaded file
            os.remove(video_path)

            if lstm_label is None:
                return render_template_string(ERROR_HTML, message="Failed to process video")

            lstm_txt = "FAKE" if lstm_label == 1 else "REAL"
            fusion_txt = "FAKE" if fusion_label == 1 else "REAL"

            return render_template_string(RESULT_HTML, 
                                           filename=filename, 
                                           lstm_txt=lstm_txt, 
                                           lstm_prob=lstm_prob, 
                                           fusion_txt=fusion_txt, 
                                           fusion_prob=fusion_prob)

        return render_template_string(ERROR_HTML, message="Invalid file type")

    return render_template_string(UPLOAD_HTML)

# ============================================================
# âœ… HTML Templates (as strings for simplicity)
# ============================================================
UPLOAD_HTML = '''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Deepfake Detector</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #f0f8ff; color: #333; }
        .container { max-width: 600px; margin-top: 100px; }
        h1 { color: #007bff; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center">Upload a Video to Detect if it's Real or Fake</h1>
        <form action="/" method="post" enctype="multipart/form-data" class="mt-4">
            <div class="input-group">
                <input type="file" class="form-control" name="video" accept=".mp4,.avi,.mov">
                <button type="submit" class="btn btn-primary">Upload and Predict</button>
            </div>
        </form>
    </div>
</body>
</html>
'''

RESULT_HTML = '''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Prediction Result</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { background-color: #f0f8ff; color: #333; }
        .container { max-width: 800px; margin-top: 50px; }
        .card { margin-bottom: 20px; }
        h1 { color: #007bff; }
        canvas { max-width: 300px; margin: auto; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center">Prediction Result for {{ filename }}</h1>
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        CNN+LSTM Model
                    </div>
                    <div class="card-body">
                        <canvas id="lstmGauge"></canvas>
                        <p class="text-center mt-3"><strong>Prediction:</strong> {{ lstm_txt }}</p>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-success text-white">
                        Fusion Model
                    </div>
                    <div class="card-body">
                        <canvas id="fusionGauge"></canvas>
                        <p class="text-center mt-3"><strong>Prediction:</strong> {{ fusion_txt }}</p>
                    </div>
                </div>
            </div>
        </div>
        <div class="text-center mt-4">
            <a href="/" class="btn btn-secondary">Upload another video</a>
        </div>
    </div>
    <script>
        // Needle plugin for Chart.js v3+
        const needlePlugin = {
            id: 'needle',
            afterDatasetDraw(chart, args, options) {
                const { ctx, data, chartArea: { width, height } } = chart;
                ctx.save();
                const needleValue = data.datasets[0].needleValue;
                const dataTotal = data.datasets[0].data.reduce((a, b) => a + b, 0);
                const angle = Math.PI + (1 / dataTotal * needleValue * Math.PI);
                const cx = width / 2;
                const cy = chart._metasets[0].data[0].y;  // Get the y position of the arc center

                // Needle
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.lineTo(height / 2.5, 0);
                ctx.lineTo(0, 5);
                ctx.fillStyle = '#444';
                ctx.fill();
                ctx.rotate(-angle);
                ctx.translate(-cx, -cy);

                // Needle dot
                ctx.beginPath();
                ctx.arc(cx, cy, 10, 0, Math.PI * 2);
                ctx.fill();

                // Value text
                ctx.font = '20px Arial';
                ctx.fillText(needleValue.toFixed(2) + '%', cx - 25, cy + 30);
                ctx.restore();
            }
        };

        Chart.register(needlePlugin);

        // Data for gauges (probability of fake * 100)
        const lstmValue = {{ lstm_prob * 100 }};
        const fusionValue = {{ fusion_prob * 100 }};

        // Common config
        const gaugeData = (value) => ({
            datasets: [{
                data: [33, 33, 34],
                backgroundColor: ['#28a745', '#ffc107', '#dc3545'],  // green, yellow, red
                needleValue: value,
                borderWidth: 2,
                cutout: '85%',
                circumference: 180,
                rotation: 270
            }]
        });

        const gaugeOptions = {
            responsive: true,
            aspectRatio: 2,
            layout: {
                padding: {
                    bottom: 30
                }
            },
            plugins: {
                legend: false,
                tooltip: false
            }
        };

        // Create LSTM gauge
        new Chart(document.getElementById('lstmGauge'), {
            type: 'doughnut',
            data: gaugeData(lstmValue),
            options: gaugeOptions
        });

        // Create Fusion gauge
        new Chart(document.getElementById('fusionGauge'), {
            type: 'doughnut',
            data: gaugeData(fusionValue),
            options: gaugeOptions
        });
    </script>
</body>
</html>
'''

ERROR_HTML = '''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Error</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #f0f8ff; color: #333; }
        .container { max-width: 600px; margin-top: 100px; }
        h1 { color: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center">Error</h1>
        <p class="text-center">{{ message }}</p>
        <div class="text-center">
            <a href="/" class="btn btn-primary">Try again</a>
        </div>
    </div>
</body>
</html>
'''

# ============================================================
# âœ… Run App
# ============================================================
if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000, debug=True)
